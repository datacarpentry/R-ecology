---
title: "SQL databases and R"
author: Data Carpentry contributors
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(
  message = FALSE, 
  echo = TRUE,
  purl = FALSE
)
```

```{r source, include=FALSE}
source("setup.R")
if (file.exists("portalR.sqlite")) file.remove("portalR.sqlite")
```

> ## Learning Objectives
>
>  By the end of this lesson the learner will:
>
> * Access a database from R
> * Run a SQL query in R using dplyr.
> * Create an SQLite database from existing .csv files.

------------

# Introduction

So far, we have dealt with small datasets that easily fit into your computer's
memory. But what about datasets that are too large for your computer to
handle as a whole? In this case, storing the data outside of R and organizing it
in a database is helpful: Connecting to the database allows you to retrieve only
the chunks needed for the current analysis.

Even better, many large datasets are already available in public or private
databases. You can query them without having to download the data first.

R can connect to almost any existing database type. For example, the
[dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) package you
used in the previous lesson supports connecting to the popular open source
databases [sqlite](https://sqlite.org/), [mysql](https://www.mysql.com/) and
[postgresql](https://www.postgresql.org/), as well as googleâ€™s
[bigquery](https://cloud.google.com/bigquery/).

```{r dplyr}
library(dplyr)
```

# Connecting to databases from R

We will continue to explore the `survey` data you are
already familiar with from previous lessons. Instead of reading the data from a 
csv file, we will connect to an SQLite database with the same information
(and more). The SQLite database is contained in a single file:
`portal_mammals.sqlite` and we point R to it with dplyr's `src_sqlite()`
command.

```{r connect}
mammals <- src_sqlite("data/portal_mammals.sqlite")
```

The `src_sqlite()` command does not load the data into the R session (as the 
`read.csv()` function did). Instead, it merely instructs R to connect to the
the `SQLite` database contained in the `portal_mammals.sqlite` file.

(You can use the `src_mysql()`, `src_postgres()` and `src_bigquery()` to connect
to the other database types supported by dplyr.)

Let's take a closer look at the `mammals` database we just connected to

```{r tables, results='markup'}
mammals
```

Just like a spreadsheet with multiple worksheets, a SQLite database can contain
multiple tables. In this case three of them are listed in the `tbls` row:

* plots
* species,
* surveys

Let's explore these tables next!

# Running SQL queries from R

We specify the table of interest with dplyr's `tbl()` function. First, we focus 
on the `surveys` table.

```{r table_details, results='markup'}
surveys <- tbl(mammals, "surveys")
head(surveys)
```

This output of the `head` command looks just like a regular `data.frame`:
The table has 9 columns and the `head()` command shows us the first 6 rows. 

Let's checkh ow many rows there are in total next.

```{r nrows, results='markup'}
nrow(tbl)
```

That's strange - R doesn't know how many rows the `survey` table contains - it
returns `NULL` instead. 

The reason for this behavior highlights a key difference between using dplyr
on datasets in memory (e.g. loaded into your R session via `read.csv()`) and
those provided by a database.

# SQL translation

Relational databases typically use a special-purpose language,
`Structured Query Language (SQL)`, to manage and query data. Behind the scenes,
dplyr 

1. translates your command into an SQL query,
2. submits it to the database
3. and translates the database's response into an R data.frame

To lift the curtain, we can use dplyr's `explain()` function to show which SQL
commands are actually sent to the database:

```{r explain, message=TRUE, results='markup'}
explain(head(surveys))
```

In this example, the database was asked to return the first 6 rows with the 

```
SELECT *
FROM `surveys`
LIMIT 6
```

SQL statement.

R never had to read or store the full `surveys` table - the hard work was
delegated to the SQLite database instead. (Luckily, we don't need to know all of
the details of the SQL translation to use dplyr.)

In the same way, we can `select()` specific columns or `filter()` rows in the
database and only retrieve the subset of the data we are interested in. Let's
try some basic queries from the previous lesson next.

# Simple database queries with dplyr

First. let's only request rows of the `surveys` table in which `weight` is less
than 5 and keep only the species_id, sex, and weight columns.

```{r pipe, results='markup'}
surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)
```

Executing this command will return a table with 10 rows and the requested
`species_id`, `sex` and `weight` columns. But why are there only 10 rows?

The last line:

```
# ... with more rows
```

indicates that there are more rows that fit our filtering criterion. Yet R was
lazy and only retrieved 10 of them.

# Lazyness

Hadley Wickham, the author of dplyr
[explains](https://cran.r-project.org/web/packages/dplyr/vignettes/databases.html):

> When working with databases, dplyr tries to be as lazy as possible:
> 
> * It never pulls data into R unless you explicitly ask for it.
> * It delays doing any work until the last possible moment: it collects together
> everything you want to do and then sends it to the database in one step.

When you construct a dplyr query, you can connect multiple verbs into a single
pipeline. For example, we combined the `filter()` and `select()` verbs using the
`%>%` pipe.

If we wanted to, we could add on even more steps, e.g. remove the `sex` column
in an additional `select` call:

```{r pipe2, results='markup'}
data.subset <- surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)

data.subset %>%
  select(-sex)
```

Just like the first `select(species_id, sex, weight)` call, the `select(-sex)`
command is not executed by R. It is sent to the database instead. Only the
_final_ result is retrieved and displayed to you.

Of course, we could always add on more steps, e.g. we could filter by
`species_id` or  minimum `weight`. That's why R doesn't retrieve the full set 
of results - instead it only retrieves the first 10 results from the database
by default. (After all, you might want to add an additional step and get the
database to do more work...)

To instruct R to stop being lazy, e.g. to retrieve all of the query results from
the database, we add the `collect()` command to our pipe. It indicates that our
database query is finished: time to get the _final_ results and load them into
the R session.

```{r collect, results='markup'}
data.subset <- surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight) %>%
  collect()
```

Now we have all 17 rows that match our query in a `data.frame` and can continue
to work with them exclusively in R, without communicating with the database.

# Complex database queries with dplyr

dplyr enables database queries across one or multiple database tables, using the
sample single- and multipe-table verbs you encountered previously. For example,
the `plots` table in the database contains information about the different
plots surveyed for this dataset To access it, we point the `tbl()` command to
it:

```{r plots, results='markup'}
plots <- tbl(mammals, "plots")
plots
```

The `plot_id` column also features in the `surveys` table.

```{r surveys, results='markup'}
surveys
```

It can be used to join matching rows from each table, e.g. to extract all
surveys for the location with `plot_id` 1:

```{r join, results='markup'}
plots %>%
  filter(plot_id == 1) %>%
  inner_join(surveys) %>% 
  collect()
```

**Note:** Without the `collect()` statement, only the first 10 matching rows
are returned. By adding `collect()`, the full set of 1,985 is retrieved.

> ## Challenge
>
>  Write a query that returns the number of rodents observed in each year.
>
>  Hint: Connect to the species table and write a query that joins the species
>  and survey tables together.
>  The query should return counts of rodents by year.

```{r left_join, results='markup'}
species <- tbl(mammals, "species")

left_join(surveys, species) %>%
  filter(taxa == "Rodent") %>%
  group_by(year) %>%
  tally %>%
  collect()
```

> ## Challenge
>
>  Write a query that returns counts of genus by `plot_id`
>
>  Hint: Write a query that joins the species, plot, and survey tables together.
>  The query should return counts of genus by plot type.

```{r genus_by_type, results='markup'}
genus.counts <- left_join(surveys, plots) %>%
  left_join(species) %>%
  group_by(plot_type, genus) %>%
  tally %>%
  collect()
```

# Creating a SQLite DB using R

So far, we have used a previously prepared SQLite database. But we can also
use R to create a new database, e.g. from existing `csv` files.  Let's recreate 
the mammals database that we've been working with, in R. First let's read in the
`csv` files.

```{r data_frames}
species <- read.csv("data/species.csv")
surveys <- read.csv("data/surveys.csv")
plots <- read.csv("data/plots.csv")
```

Creating a new SQLite database with dplyr is easy. You can re-use the same
command we used above to open an existing `.sqlite` file. The `create = TRUE`
argument instructs R to create a new, empty database instead.

**Warning:** When `create = TRUE` is added, any existing database at the same
location is overwritten without warning.

```{r create_database}
myDB <- "portalR.sqlite"
my_db <- src_sqlite(myDB, create = TRUE)
```

Currently, our new databse it empty, it doesn't contain any tables:

```{r empty, results='markup'}
my_db
```

To add tables, we copy the existing data.frames into the database one by one:

```{r copy, results='markup'}
copy_to(my_db, surveys)
copy_to(my_db, plots)
my_db
```

If you check the location of our database you'll see that data is automatically
being written to disk. Not only does R and dplyr provide easy ways to query
existing databases, it also allows you to easily create your own databases from
flat files.

> ## Challenge
>
> Add the remaining species table to the my_db database and run some of your
> queries from earlier in the lesson to verify that you have
> faithfully recreated the mammals database.

**Note:** In this example, we first loaded all of the data into the R session by
reading the three csv files. Because all the data has to flow through R, 
this is not suitable for very large datasets.
